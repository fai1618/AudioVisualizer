<<<<<<< HEAD
    var scene = new THREE.Scene();    // カメラ設定 ------------------------------------------        var fov = 60;        var width = $(window).width(); // 横幅        var height = $(window).height(); // 縦幅                var aspect = width/height;// aspect: アスペクト比、カメラで撮影したものの縦横比        var near = 1;//カメラからの撮影開始位置、これより近いものは撮影しない        var far = 20000;//カメラからの撮影終了位置、これより遠いものは撮影しない        //カメラ追加 -------------------------------------------        // camera 1        IcosCamera = new THREE.PerspectiveCamera( fov, aspect, near, far);        //scene.add(IcosCamera);        IcosCamera.position.set(0,0,0);        IcosCamera.lookAt(new THREE.Vector3(50,0,0));        // camera 2        Icos2Camera = new THREE.PerspectiveCamera( fov, aspect, near, far);        Icos2Camera.position.set(0,0,0);        Icos2Camera.lookAt(new THREE.Vector3(0,0,50));        //scene.add(Icos2Camera);    // レンダラー追加 --------------------------------------        var renderer = new THREE.WebGLRenderer({antialias:true});        renderer.setSize(width,height); // canvasのサイズ設定        renderer.autoClear = false;//MUST!!(2つ以上のカメラ)        THREEx.WindowResize(renderer, IcosCamera);        THREEx.WindowResize(renderer, Icos2Camera);        $("body").append(renderer.domElement);    // オブジェクト追加 ------------------------------------        var IcosGeometry = new THREE.IcosahedronGeometry( 10, 1 );        var IcosMaterial = new THREE.MeshBasicMaterial( {color: 0x00c8ff, wireframe:true, wireframeLinewidth:1, opacity:0.1} );//lightいらない        var Icos = new THREE.Mesh(IcosGeometry, IcosMaterial);        Icos.position.set(50,0,0);        scene.add(Icos);        var Icos2Geometry = new THREE.IcosahedronGeometry( 10, 0 );        var Icos2Material = new THREE.MeshBasicMaterial( {color: 0x00ffc8, wireframe:true, wireframeLinewidth:1, opacity:0.1} );//lightいらない        var Icos2 = new THREE.Mesh(Icos2Geometry, Icos2Material);        Icos2.position.set(0,0,50);        scene.add(Icos2);//render準備    var speedy = 0.1;    var speedx = 0.1;    var preIcosPosition = {};    var preIcos2Position = {};    // レンダリング ---------------------------------------    function render() {        requestAnimationFrame(render);        Icos.scale.set(1,1,1);        Icos2.scale.set(1,1,1);        Icos.rotation.y -= speedy/16*Math.random();        Icos.rotation.x += speedx/16;        Icos2.rotation.y -= speedy/16*Math.random();        Icos2.rotation.x += speedx/16;        if(difference > 0.01){            Icos.scale.x += difference/50*2;            Icos.scale.y += difference/50*2;            Icos.scale.z += difference/50*2;            Icos2.scale.x += difference/50*2;            Icos2.scale.y += difference/50*2;            Icos2.scale.z += difference/50*2;            var difroy = speedy*Math.random()*difference;            Icos.rotation.y -= difroy;            Icos.rotation.x += speedx*difference;            Icos2.rotation.y -= difroy;            Icos2.rotation.x += speedx*difference;        }        if(difference > 1){            //IcosMaterial.color.set('#'+Math.floor(Math.random() * 0xFFFFFF).toString(16));            //Icos2Material.color.set('#'+Math.floor(Math.random() * 0xFFFFFF).toString(16));        }        if(difference > 1){            //lineを引くため            preIcosPosition["x"] = Icos.position.x;            preIcosPosition["y"] = Icos.position.y;            preIcosPosition["z"] = Icos.position.z;            //動き            move(Icos,IcosCamera,difference,3,-3);            //chaseLine            addLine(Icos,preIcosPosition,0x00c8ff);        }        if(difference > 0.1){            //lineを引くため            preIcos2Position["x"] = Icos2.position.x;            preIcos2Position["y"] = Icos2.position.y;            preIcos2Position["z"] = Icos2.position.z;            move(Icos2,Icos2Camera,difference,3,-3);            addLine(Icos2,preIcos2Position,0x00ffc8);        }        var SCREEN_WIDTH = $(window).width(), SCREEN_HEIGHT = $(window).height();        Icos2Camera.aspect = 0.5 * SCREEN_WIDTH / SCREEN_HEIGHT;        IcosCamera.aspect = 0.5 * SCREEN_WIDTH / SCREEN_HEIGHT;                Icos2Camera.updateProjectionMatrix();        IcosCamera.updateProjectionMatrix();        // setViewport parameters:        //  lower_left_x, lower_left_y, viewport_width, viewport_height        renderer.setViewport( 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT );        renderer.clear();        // シーンとカメラを渡してレンダリング            // left side            renderer.setViewport( 1, 1,   0.5 * SCREEN_WIDTH - 2, SCREEN_HEIGHT - 2 );            renderer.render( scene, Icos2Camera );                        // right side            renderer.setViewport( 0.5 * SCREEN_WIDTH + 1, 1,   0.5 * SCREEN_WIDTH - 2, SCREEN_HEIGHT - 2 );            renderer.render( scene, IcosCamera );    }    $(function(){        render();    });    //-----------------------------------------------    function move(object,camera,difference,moveMax,moveMin){//カメラ追従ない場合、camera : null        var addPositionX = Math.round(difference*100)/10*Math.random()*(2 - 0.5+1)+0.5;        var addPositionY = -1+Math.round(difference*100)/10*Math.random()*(1.5 - 0.5+1)+0.5;        var addPositionZ = Math.round((Math.random() * (moveMax - moveMin + 1) + moveMin)*difference*1000)/1000;                //マイナスが少ない気がするので付け足し        if (Math.random() >= 0.4){            addPositionX *= -1;        }        if (Math.random() >= 0.4){            addPositionY *= -1;        }        if (Math.random() >= 0.4){            addPositionZ *= -1;        }        //x,y,zどの方向に動くか        var randomMovingJudge = Math.floor( Math.random() * (2 - 0 + 1) ) + 0;//JudgeMax:2, JudgeMin:0        if (difference > 0.01) {            switch(randomMovingJudge){                    case 0:object.position.x -= addPositionX;break;                    case 1:object.position.y -= addPositionY;break;                    case 2:object.position.z -= addPositionZ;break;                    default:alert("randomMovingJudge("+object+"):無効な値");            }            if(camera !== null){                switch(randomMovingJudge){                    case 0:camera.position.x -= addPositionX;break;                    case 1:camera.position.y -= addPositionY;break;                    case 2:camera.position.z -= addPositionZ;break;                    default:alert("randomMovingJudge("+camera+"):無効な値");                }            }        }    }    //-----------------------------------------------    function addLine(object,prePosition,color){        //add line        var lineGeometry = new THREE.Geometry();        var lineMaterial = new THREE.LineBasicMaterial({color: color});        lineGeometry.vertices.push(new THREE.Vector3(prePosition["x"], prePosition["y"], prePosition["z"]));        lineGeometry.vertices.push(new THREE.Vector3(object.position.x, object.position.y, object.position.z));        var line = new THREE.Line(lineGeometry, lineMaterial);        scene.add(line);    }
=======
    var scene = new THREE.Scene();    // カメラ設定 ------------------------------------------    var fov = 60;    var width = $(window).width(); // 横幅    var height = $(window).height(); // 縦幅        var aspect = width/height;// aspect: アスペクト比、カメラで撮影したものの縦横比    var near = 1;//カメラからの撮影開始位置、これより近いものは撮影しない    var far = 20000;//カメラからの撮影終了位置、これより遠いものは撮影しない            // camera 1    IcosCamera = new THREE.PerspectiveCamera( fov, aspect, near, far);    //scene.add(IcosCamera);    IcosCamera.position.set(0,0,0);    IcosCamera.lookAt(new THREE.Vector3(50,0,0));    // camera 2    Icos2Camera = new THREE.PerspectiveCamera( fov, aspect, near, far);    Icos2Camera.position.set(0,0,0);    Icos2Camera.lookAt(new THREE.Vector3(0,0,50));    //scene.add(Icos2Camera);    // レンダラー追加 ----------------------------------------    var renderer = new THREE.WebGLRenderer({antialias:true});    renderer.setSize(width,height); // canvasのサイズ設定    renderer.autoClear = false;    THREEx.WindowResize(renderer, IcosCamera);    THREEx.WindowResize(renderer, Icos2Camera);    $("body").append(renderer.domElement);    // オブジェクト追加 ----------------------------------------            var IcosGeometry = new THREE.IcosahedronGeometry( 10, 1 );            var IcosMaterial = new THREE.MeshBasicMaterial( {color: 0x00c8ff, wireframe:true, wireframeLinewidth:1, opacity:0.1} );//lightいらない            var Icos = new THREE.Mesh(IcosGeometry, IcosMaterial);            Icos.position.set(50,0,0);            scene.add(Icos);            var Icos2Geometry = new THREE.IcosahedronGeometry( 10, 0 );            var Icos2Material = new THREE.MeshBasicMaterial( {color: 0x00ffc8, wireframe:true, wireframeLinewidth:1, opacity:0.1} );//lightいらない            var Icos2 = new THREE.Mesh(Icos2Geometry, Icos2Material);            Icos2.position.set(0,0,50);            scene.add(Icos2);var speedy = 0.1;var speedx = 0.1;var preIcosPosition = {};var preIcos2Position = {};    // レンダリング ----------------------------------------    function render() {        requestAnimationFrame(render);                Icos.scale.set(1,1,1);                Icos2.scale.set(1,1,1);                Icos.rotation.y -= speedy/16*Math.random();                Icos.rotation.x += speedx/16;                Icos2.rotation.y -= speedy/16*Math.random();                Icos2.rotation.x += speedx/16;                if(difference > 0.01){                    Icos.scale.x += difference/50*2;                    Icos.scale.y += difference/50*2;                    Icos.scale.z += difference/50*2;                    Icos2.scale.x += difference/50*2;                    Icos2.scale.y += difference/50*2;                    Icos2.scale.z += difference/50*2;                    var difroy = speedy*Math.random()*difference;                    Icos.rotation.y -= difroy;                    Icos.rotation.x += speedx*difference;                    Icos2.rotation.y -= difroy;                    Icos2.rotation.x += speedx*difference;                }                if(difference > 1){                    //IcosMaterial.color.set('#'+Math.floor(Math.random() * 0xFFFFFF).toString(16));                    //Icos2Material.color.set('#'+Math.floor(Math.random() * 0xFFFFFF).toString(16));                }                if(difference > 1){                //lineを引くため                preIcosPosition["x"] = Icos.position.x;                preIcosPosition["y"] = Icos.position.y;                preIcosPosition["z"] = Icos.position.z;                //動き                move(Icos,IcosCamera,difference,3,-3);                //chaseLine                addLine(Icos,preIcosPosition,0x00c8ff);            }            if(difference > 0.1){                //lineを引くため                preIcos2Position["x"] = Icos2.position.x;                preIcos2Position["y"] = Icos2.position.y;                preIcos2Position["z"] = Icos2.position.z;                move(Icos2,Icos2Camera,difference,3,-3);                addLine(Icos2,preIcos2Position,0x00ffc8);            }    var SCREEN_WIDTH = $(window).width(), SCREEN_HEIGHT = $(window).height();    Icos2Camera.aspect = 0.5 * SCREEN_WIDTH / SCREEN_HEIGHT;    IcosCamera.aspect = 0.5 * SCREEN_WIDTH / SCREEN_HEIGHT;    Icos2Camera.updateProjectionMatrix();    IcosCamera.updateProjectionMatrix();                // setViewport parameters:    //  lower_left_x, lower_left_y, viewport_width, viewport_height    renderer.setViewport( 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT );    renderer.clear();            // left side            renderer.setViewport( 1, 1,   0.5 * SCREEN_WIDTH - 2, SCREEN_HEIGHT - 2 );            renderer.render( scene, Icos2Camera );                        // right side            renderer.setViewport( 0.5 * SCREEN_WIDTH + 1, 1,   0.5 * SCREEN_WIDTH - 2, SCREEN_HEIGHT - 2 );            renderer.render( scene, IcosCamera );            // シーンとカメラを渡してレンダリング            //renderer.render(scene, Icos2Camera);    }    $(function(){        render();    });    //-----------------------------------------------    function move(object,camera,difference,moveMax,moveMin){//カメラ追従ない場合、camera : null        var addPositionX = Math.round(difference*100)/10*Math.random()*(2 - 0.5+1)+0.5;                var addPositionY = -1+Math.round(difference*100)/10*Math.random()*(1.5 - 0.5+1)+0.5;                var addPositionZ = Math.round((Math.random() * (moveMax - moveMin + 1) + moveMin)*difference*1000)/1000;                                //マイナスが少ない気がするので付け足し                if (Math.random() >= 0.4){                    addPositionX *= -1;                }                if (Math.random() >= 0.4){                    addPositionY *= -1;                }                if (Math.random() >= 0.4){                    addPositionZ *= -1;                }                //x,y,zどの方向に動くか                var randomMovingJudge = Math.floor( Math.random() * (2 - 0 + 1) ) + 0;//JudgeMax:2, JudgeMin:0                if (difference > 0.01) {                    switch(randomMovingJudge){                            case 0:object.position.x -= addPositionX;break;                            case 1:object.position.y -= addPositionY;break;                            case 2:object.position.z -= addPositionZ;break;                            default:alert("randomMovingJudge("+object+"):無効な値");                    }                    if(camera !== null){                        switch(randomMovingJudge){                            case 0:camera.position.x -= addPositionX;break;                            case 1:camera.position.y -= addPositionY;break;                            case 2:camera.position.z -= addPositionZ;break;                            default:alert("randomMovingJudge("+camera+"):無効な値");                        }                    }                }    }    //-----------------------------------------------    function addLine(object,prePosition,color){    //add line        var lineGeometry = new THREE.Geometry();        var lineMaterial = new THREE.LineBasicMaterial({color: color});        lineGeometry.vertices.push(new THREE.Vector3(prePosition["x"], prePosition["y"], prePosition["z"]));        lineGeometry.vertices.push(new THREE.Vector3(object.position.x, object.position.y, object.position.z));        var line = new THREE.Line(lineGeometry, lineMaterial);        scene.add(line);    }
>>>>>>> master
