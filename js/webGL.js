    //シーン作成 ------------------------------------------    var scene = new THREE.Scene();         // カメラ設定 ------------------------------------------    // fov: 画角(視野角)    var fov = 60;    var width = $(window).width()*0.99; // 横幅    var height = $(window).height()*0.9; // 縦幅        var aspect = width/height;// aspect: アスペクト比、カメラで撮影したものの縦横比    var near = 1;//カメラからの撮影開始位置、これより近いものは撮影しない    var far = 20000;//カメラからの撮影終了位置、これより遠いものは撮影しない            // カメラ作成    var camera = new THREE.PerspectiveCamera(fov, aspect, near, far);    // カメラ配置    var cameraPositionX = 0;    var cameraPositionY = 200;    var cameraPositionZ = -300;    camera.position.set(cameraPositionX, cameraPositionY, cameraPositionZ); // (x, y, z)        //カメラ視点    camera.lookAt(new THREE.Vector3(0, 0, 0));    scene.add(camera);        // レンダラー追加 ----------------------------------------    var renderer = new THREE.WebGLRenderer({antialias:true});    renderer.setSize(width,height); // canvasのサイズ設定    renderer.setClearColor( new THREE.Color(0x000000) );//背景色    THREEx.WindowResize(renderer, camera);    $("body").append(renderer.domElement);    // ライティング設定 ------------------------------------        var color = 'white'; //光の色        // ライトオブジェクト作成            //平行光                /*var directionalLight = new THREE.DirectionalLight(color);                directionalLight.position.set(0, 30, 0); // 光源の角度を設定(x,y,z)                scene.add(directionalLight);*/            //点光                var pointLight = new THREE.PointLight (0xffffff,1.0,0);//色,強さ,不明                pointLight.position.set(0, 100, 300);                scene.add(pointLight);        // オブジェクト追加 ----------------------------------------                    //多角形            var IcosGeometry = new THREE.IcosahedronGeometry( 20, 1 );                        var IcosMaterial = new THREE.MeshBasicMaterial( {color: 0x00c8ff, wireframe:true, wireframeLinewidth:1, opacity:0.1} );//lightいらない                        var Icos = new THREE.Mesh(IcosGeometry, IcosMaterial);            Icos.position.set(0, 10, 0);                        scene.add(Icos);            //多角形2            var Icos2Geometry = new THREE.IcosahedronGeometry( 20, 0 );                        var Icos2Material = new THREE.MeshBasicMaterial( {color: 0x00ffc8, wireframe:true, wireframeLinewidth:1, opacity:0.1} );//lightいらない                        var Icos2 = new THREE.Mesh(Icos2Geometry, Icos2Material);                        Icos2.position.set(0, 0, 0);                        scene.add(Icos2);        //cube            var cubeGeometry = new THREE.BoxGeometry(1, 1, 1); // 立方体作成            var cubeMaterial = new THREE.MeshBasicMaterial({color: 0x00c8ff}); // 材質作成    //オブジェクト終了------------------------------------------    var speedy = 0.1;    var speedx = 0.1;    var preIcosPosition = {};    var preIcos2Position = {};    // レンダリング ----------------------------------------    function render() {                renderer.setClearColor( new THREE.Color(0x000000) );//背景色            requestAnimationFrame(render);                Icos.scale.set(1,1,1);                Icos2.scale.set(1,1,1);                if(difference > 0.01){                    Icos.scale.x += difference/50*2;                    Icos.scale.y += difference/50*2;                    Icos.scale.z += difference/50*2;                    Icos2.scale.x += difference/50*2;                    Icos2.scale.y += difference/50*2;                    Icos2.scale.z += difference/50*2;                                        if(difference > 1){                        //IcosMaterial.color.set('#'+Math.floor(Math.random() * 0xFFFFFF).toString(16));                        //Icos2Material.color.set('#'+Math.floor(Math.random() * 0xFFFFFF).toString(16));                    }                }                        if (difference > 0.01) {//difに合わせたIcosの回転(自転)                var difroy = speedy*Math.random()*difference;                Icos.rotation.y -= difroy;                Icos.rotation.x += speedx*difference;                Icos2.rotation.y -= difroy;                Icos2.rotation.x += speedx*difference;            }            Icos.rotation.y -= speedy/16*Math.random();            Icos.rotation.x += speedx/16;            Icos2.rotation.y -= speedy/16*Math.random();            Icos2.rotation.x += speedx/16;                        if(difference > 1){                //lineを引くため                preIcosPosition["x"] = Icos.position.x;                preIcosPosition["y"] = Icos.position.y;                preIcosPosition["z"] = Icos.position.z;                preIcos2Position["x"] = Icos2.position.x;                preIcos2Position["y"] = Icos2.position.y;                preIcos2Position["z"] = Icos2.position.z;                                //動き                move(Icos,true,difference,3,-3);                move(Icos2,false,difference,3,-3);                                //chaseLine                addLine(Icos,preIcosPosition,0x00c8ff);                addLine(Icos2,preIcos2Position,0x00ffc8);            }            if(difference > 0.1){                //lineを引くため                preIcos2Position["x"] = Icos2.position.x;                preIcos2Position["y"] = Icos2.position.y;                preIcos2Position["z"] = Icos2.position.z;                                move(Icos2,false,difference,10,-10);                                addLine(Icos2,preIcos2Position,0x00ffc8);            }            // シーンとカメラを渡してレンダリング            renderer.render(scene, camera);    }        $(function(){        render();    });    //-----------------------------------------------    function move(object,cameraTF,difference,moveMax,moveMin){//cameraTFはカメラ追従TF        var addPositionX = Math.round(difference*100)/10*Math.random()*(2 - 0.5+1)+0.5;                var addPositionY = -1+Math.round(difference*100)/10*Math.random()*(1.5 - 0.5+1)+0.5;                var addPositionZ = Math.round((Math.random() * (moveMax - moveMin + 1) + moveMin)*difference*1000)/1000;                                //マイナスが少ない気がするので付け足し                if (Math.random() >= 0.4){                    addPositionX *= -1;                }                if (Math.random() >= 0.4){                    addPositionY *= -1;                }                if (Math.random() >= 0.4){                    addPositionZ *= -1;                }                //x,y,zどの方向に動くか                var randomMovingJudge = Math.floor( Math.random() * (2 - 0 + 1) ) + 0;//JudgeMax:2, JudgeMin:0                if (difference > 0.01) {                    switch(randomMovingJudge){                            case 0:object.position.x -= addPositionX;break;                            case 1:object.position.y -= addPositionY;break;                            case 2:object.position.z -= addPositionZ;break;                            default:alert("randomMovingJudge("+object+"):無効な値");                    }                    if(cameraTF){//追従                        switch(randomMovingJudge){                            case 0:camera.position.x -= addPositionX;break;                            case 1:camera.position.y -= addPositionY;break;                            case 2:camera.position.z -= addPositionZ;break;                            default:alert("randomMovingJudge("+object+"):無効な値");                        }                    }                }    }    //-----------------------------------------------    function addLine(object,prePosition,color){    //add line        var lineGeometry = new THREE.Geometry();        var lineMaterial = new THREE.LineBasicMaterial({color: color});        lineGeometry.vertices.push(new THREE.Vector3(prePosition["x"], prePosition["y"], prePosition["z"]));        lineGeometry.vertices.push(new THREE.Vector3(object.position.x, object.position.y, object.position.z));        var line = new THREE.Line(lineGeometry, lineMaterial);        scene.add(line);    }